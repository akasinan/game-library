// Code generated by goa v3.7.6, DO NOT EDIT.
//
// GameManagement service
//
// Command:
// $ goa gen github.com/akasinan/game-library/game_management_service/design

package gamemanagement

import (
	"context"

	gamemanagementviews "github.com/akasinan/game-library/game_management_service/gen/game_management/views"
	goa "goa.design/goa/v3/pkg"
)

// Service is the GameManagement service interface.
type Service interface {
	// Creates a game in the postgres database.
	Create(context.Context, *CreatePayload) (res *CreateResult, err error)
	// Update a game’s fields in the database. Would be used if new information on
	// the game was added such as finalized release dates, ports to new platforms
	// etc.
	Update(context.Context, *UpdatePayload) (err error)
	// Retrieve and show a game from the database. Will be used to show a game’s
	// full profile when on the game’s page on the site.
	Show(context.Context, *ShowPayload) (res *Game, err error)
	// Retrieve a list of all games from the database. Filter will be used to
	// filter out games for searching by values like name. Can be used to retrieve
	// a game’s ID to use the Show endpoint.
	Index(context.Context, *IndexPayload) (res *GameList, err error)
	// Delete a game from the database by ID. Could be used by site admins in case
	// of an upcoming game’s cancellation or a mistake.
	Delete(context.Context, *DeletePayload) (err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "GameManagement"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [5]string{"create", "update", "show", "index", "delete"}

// CreatePayload is the payload type of the GameManagement service create
// method.
type CreatePayload struct {
	// Name of the game
	Name string
	// Initial release date of game
	ReleaseDate *string
	// An array of genres the game falls under
	Genre []string
	// A list of Platforms the game has been released on. Consoles/PC etc.
	Platforms []string
	// Name of Game’s developer
	Developer *string
	// Name of Game’s publisher
	Publisher *string
}

// CreateResult is the result type of the GameManagement service create method.
type CreateResult struct {
	// Location of the newly created game
	Location *string
}

// DeletePayload is the payload type of the GameManagement service delete
// method.
type DeletePayload struct {
	// ID of the game in the Postgres database
	ID uint64
}

// Game is the result type of the GameManagement service show method.
type Game struct {
	// ID of the game in the Postgres database
	ID uint64
	// Name of the game
	Name string
	// Initial release date of game
	ReleaseDate *string
	// An array of genres the game falls under
	Genre []string
	// A list of Platforms the game has been released on. Consoles/PC etc.
	Platforms []string
	// Name of Game’s developer
	Developer *string
	// Name of Game’s publisher
	Publisher *string
	// Game creation timestamp
	CreatedAt string
	// Game last updated timestamp
	UpdatedAt *string
}

type GameCollection []*Game

// GameList is the result type of the GameManagement service index method.
type GameList struct {
	// List of games
	Values GameCollection
}

// IndexPayload is the payload type of the GameManagement service index method.
type IndexPayload struct {
	// Filter for filtering list of games returned.
	// The following filters are supported:
	// | Filter | Description | Allowed Operator | Behavior | Example |
	// | --- | ---| --- | --- | --- |
	// | name | Filters on the game name | co | Contains - The entire operator
	// value must be a substring of the attribute value for a match. |  name co
	// 'Remaster' |
	// |	|	| eq | Equal - The attribute and operator values must be identical for a
	// match. | name eq 'Super Mario 64'  |
	// * All operators are case-sensitive and only lowercase is allowed.
	// e.g:
	// valid	: eq
	// invalid : EQ

	// * Filters can be combined using the and/or logical operator.
	// e.g: (name co 'Mario' or name eq 'Super Mario 64')

	// * When used as a query string, the filter parameter value must be URL
	// encoded.
	// e.g: ?filter=(name%20co%20'Mario'%20or%20name%20eq%20'Super Mario 64')

	// When using cURL, the same expression can be URL encoded as follows:
	// $ curl -i -H "$AUTH_HEADER" {$BASE_URL}/games \
	// -G --data-urlencode "filter=(name co 'Mario' or name eq 'Super Mario 64')"

	Filter string
}

// ShowPayload is the payload type of the GameManagement service show method.
type ShowPayload struct {
	// The ID of the game
	ID uint64
}

// UpdatePayload is the payload type of the GameManagement service update
// method.
type UpdatePayload struct {
	// ID of the game in the Postgres database
	ID uint64
	// Initial release date of game
	ReleaseDate *string
	// An array of genres the game falls under
	Genre []string
	// A list of Platforms the game has been released on. Consoles/PC etc.
	Platforms []string
	// Name of Game’s developer
	Developer *string
	// Name of Game’s publisher
	Publisher *string
}

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadGateway builds a goa.ServiceError from an error.
func MakeBadGateway(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_gateway",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalError builds a goa.ServiceError from an error.
func MakeInternalError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "internal_error",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeConflict builds a goa.ServiceError from an error.
func MakeConflict(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "conflict",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeUnprocessableEntity builds a goa.ServiceError from an error.
func MakeUnprocessableEntity(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unprocessable_entity",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewGame initializes result type Game from viewed result type Game.
func NewGame(vres *gamemanagementviews.Game) *Game {
	return newGame(vres.Projected)
}

// NewViewedGame initializes viewed result type Game from result type Game
// using the given view.
func NewViewedGame(res *Game, view string) *gamemanagementviews.Game {
	p := newGameView(res)
	return &gamemanagementviews.Game{Projected: p, View: "default"}
}

// NewGameList initializes result type GameList from viewed result type
// GameList.
func NewGameList(vres *gamemanagementviews.GameList) *GameList {
	return newGameList(vres.Projected)
}

// NewViewedGameList initializes viewed result type GameList from result type
// GameList using the given view.
func NewViewedGameList(res *GameList, view string) *gamemanagementviews.GameList {
	p := newGameListView(res)
	return &gamemanagementviews.GameList{Projected: p, View: "default"}
}

// newGame converts projected type Game to service type Game.
func newGame(vres *gamemanagementviews.GameView) *Game {
	res := &Game{
		ReleaseDate: vres.ReleaseDate,
		Developer:   vres.Developer,
		Publisher:   vres.Publisher,
		UpdatedAt:   vres.UpdatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.CreatedAt != nil {
		res.CreatedAt = *vres.CreatedAt
	}
	if vres.Genre != nil {
		res.Genre = make([]string, len(vres.Genre))
		for i, val := range vres.Genre {
			res.Genre[i] = val
		}
	}
	if vres.Platforms != nil {
		res.Platforms = make([]string, len(vres.Platforms))
		for i, val := range vres.Platforms {
			res.Platforms[i] = val
		}
	}
	return res
}

// newGameView projects result type Game to projected type GameView using the
// "default" view.
func newGameView(res *Game) *gamemanagementviews.GameView {
	vres := &gamemanagementviews.GameView{
		ID:          &res.ID,
		Name:        &res.Name,
		ReleaseDate: res.ReleaseDate,
		Developer:   res.Developer,
		Publisher:   res.Publisher,
		CreatedAt:   &res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
	}
	if res.Genre != nil {
		vres.Genre = make([]string, len(res.Genre))
		for i, val := range res.Genre {
			vres.Genre[i] = val
		}
	}
	if res.Platforms != nil {
		vres.Platforms = make([]string, len(res.Platforms))
		for i, val := range res.Platforms {
			vres.Platforms[i] = val
		}
	}
	return vres
}

// newGameList converts projected type GameList to service type GameList.
func newGameList(vres *gamemanagementviews.GameListView) *GameList {
	res := &GameList{}
	if vres.Values != nil {
		res.Values = newGameCollection(vres.Values)
	}
	return res
}

// newGameListView projects result type GameList to projected type GameListView
// using the "default" view.
func newGameListView(res *GameList) *gamemanagementviews.GameListView {
	vres := &gamemanagementviews.GameListView{}
	if res.Values != nil {
		vres.Values = newGameCollectionView(res.Values)
	}
	return vres
}

// newGameCollection converts projected type GameCollection to service type
// GameCollection.
func newGameCollection(vres gamemanagementviews.GameCollectionView) GameCollection {
	res := make(GameCollection, len(vres))
	for i, n := range vres {
		res[i] = newGame(n)
	}
	return res
}

// newGameCollectionView projects result type GameCollection to projected type
// GameCollectionView using the "default" view.
func newGameCollectionView(res GameCollection) gamemanagementviews.GameCollectionView {
	vres := make(gamemanagementviews.GameCollectionView, len(res))
	for i, n := range res {
		vres[i] = newGameView(n)
	}
	return vres
}
